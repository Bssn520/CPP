#include <iostream>
#include <cstdlib>

/**
 * 复合类型是指基于其他类型定义的类型，比如指针、引用。
 * 
 */

int main()
{
    /**
     * 1. 引用
     * 
     * 引用即别名，引用并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字。
     * 
     * 注意: 
     * 1. 引用的类型要与对象的类型严格匹配。
     * 2. 引用必须显式初始化。
     * 3. 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。
     * 
     */
    int i = 1024, i2 = 2048;
    int &r = i;
    printf("Value of i: %d\n", r); // 1024

    int i3, &r3 = i3;
    i3 = 5;
    r3 = 10;

    std::cout << i3 << " " << r3 << std::endl; // 10 10

    /**
     * 2. 指针
     * 
     * 注意:
     * 1. 指针的类型要与对象的类型严格匹配。
     * 
     * 指针的值（即地址）应属下列4种状态之一： 
     * 1. 指向一个对象。 
     * 2. 指向紧邻对象所占空间的下一个位置。 
     * 3. 空指针，意味着指针没有指向任何对象。 
     * 4. 无效指针，也就是上述情况之外的其他值。
     * 
     */

    // 利用 解引用符* 来获得指针所指的对象
    int ival = 42;
    int* p = &ival;
    std::cout << *p << std::endl; // 42

    /**
     * 空指针
     * 空指针不指向任何对象，在试图使用一个指针前代码可以首先检查它是否为空。
     * 
     * 得到空指针最直接的办法:
     * 1. 就是用字面值 nul1ptr 来初始化指针,这也是C++11新标准刚刚引入的一种方法。
     * nu1lptr 是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。
     * 2. 另一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来生成空指针。
     * 3. 过去的程序还会用到一个名力 NULL 的预处理变量（preprocessor variable）
     * 来给指针赋值，这个变量在头文件 cstdlib 中定义，它的值就是 0。
     * 
     * 建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。
     * 如果实在不清楚指针应该指向何处，就把它初始化为 nullptr或者0， 
     * 这样程序就能检测并知道它没有指向任何具体的对象了。
     */
    int* p1 = nullptr; // 等价于 int* p1 = 0;
    int * p2 = 0;
    // 需要首先 #include cstdlib
    int* p3 = NULL;

    /**
     * void* 指针
     * 
     * void* 指针是一种特殊的指针类型，可用于存放人意对象的地址。
     * 
     * 利用void*指针能做的事儿比较有限：
     * 拿它和别的指针比较、作为函数的输入或输出，或 者赋给另外一个 void*指针。
     * 不能直接操作void*指针所指的对象，因为我们并不知道 这个对象到底是什么类型，
     * 也就无法确定能在这个对象上做哪些操作。
     */
    double obj = 3.14, *pd = &obj;
    void* pv = &obj; // void* 可以存放任意类型对象的地址
    pv = pd; // pv 可以存放任意类型的指针

    /**
     * 多级指针
     */
    int ival2 = 1024;
    int *pi2 = &ival2;
    int **ppi2 = &pi2;
    // 此时想要访问最原始的那个对象，需要对指针做两次解引用:
    std::cout << "The value of ival2\n"
                << "direct value: " << ival2 << "\n"
                << "indirect value: " << *pi2 << "\n"
                << "double indirect value: " << **ppi2 << std::endl;

    /**
     * 指向指针的引用
     * 
     * 引用本身不是一个对象，因此不能定义指向引用的指针。
     * 但指针是对象，所以存在对指针的引用。
     * 
     * 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它 的真实含义。
     * 
     * 要理解r33的类型到底是什么，最简单的办法是从右向左阅读r33的定义。
     * 离变量名最近的符号（此例中是&r33的符号&）对变量的类型有最直接的影响，因此r33是一个引用。
     * 声明符的其余部分用以确定引用的类型是什么，此例中的符号*说明r33引用的是一个指针。
     * 最后， 声明的基本数据类型部分指出r33引用的是一个int指针。
     */
    int i3 = 42;
    int *p3;
    int *&r33 = p3; // r33 是一个对指针p3的引用

    r33 = &i3; // r33 引用了一个指针，因此给r33赋值&i3就是令p3指向i3
    *r33 =0; // 解引用 r 得到 i, 也就是p指向的对象，将i的值改为0


/**
 * 像&和*这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，
 * 符号的上下文决定了符号的意义：
 * int i = 42; 
 * int &r = i;  // &紧随类型名出现，因此是声明的一部分，r是一个引用
 * int *p;      // *紧随类型名出现，因此是声明的一部分，p是一个指针
 * p = &i;      // &出现在表达式中，是一个取地址符
 * *p = i;      // *出现在表达式中，是一个解引用符
 * int &r2 = *p; // &是声明的一部分，*是一个解引用符
 * 
 * 指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同:
 * 其中最重要的一点就是引用本身并非一个对象。
 * 1. 一旦定义了引用，就无法令其再绑定到另外的对象，
 * 之后每次使用这个引用都是访问它最初绑定的那个对象。 
 * 2. 指针和它存放的地址之间就没有这种限制了。和其他任何变量（只要不是引用）一样，
 * 给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。
 */
    return 0;
}