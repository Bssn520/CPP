/*
 * @Author: Bssn520 Bssn520@duck.com
 * @Date: 2024-11-04 13:50:27
 * @LastEditTime: 2024-11-05 09:31:52
 * @Description: 访问容器内元素
 * 
 */
/*
访问元素

如果容器中没有元素，访问操作的结果是未定义的。
每个顺序容器都有一个front成员函数，除 forward_list 外的顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用。
// 在解引用一个迭代器或调用 Eront 或 back之前检查是否有元素
if (!c.empty())
{
    // val 和va12是c 中第一个元素值的拷贝
    auto val = *c.begin(), val2 = c.front();
    // val3 和val4是c 中最后一个元素值的拷贝
    auto last = c.end();
    auto val3 = *(--last);  // 不能递减 forward_list 迭代器
    auto val4 = c.back();   // forward_list 不支持
}
在调用 front 和 back (或解引用 begin 和 end 返回的迭代器)之前，要确保c非空。否则会引发未定义行为。

at 和 下标操作只适用于 string vector deque array
back() 不适用于 forward_list
c.back()    // 返回c中尾元素的引用。若c为空，函数行为未定义
c.front()   // 返回c中首元素的引用。若c为空，函数行为未定义
c[n]        // 返回c中下标为n的元素的引用，n是一个无符号整数。若n>=c.size（），则函数行为未定义
c.at(n)     // 返回下标为n 的元素的引用。如果下标越界，则拋出一个 out_of_range 异常

注意: 对一个空容器调用 front 和 back，就像使用一个越界的下标一样，是一种严重的程序设计错误。

*/

/*
访问成员函数返回的是引用

在容器中访问元素的成员函数（即，front、back、下标和 at）返回的都是引用。如果容器是一个 const 对象，则返回值是 const 的引用。

*/

/*
下标操作和安全的随机访问

提供快速随机访问的容器（string、vector、deque 和 array）也都提供下标运算符。

*/


/*
删除元素

与添加元素的多种方式类似，（非 array）容器也有多种删除元素的方式。

c.pop_back()    // 删除c中尾元素。若为空，则函数行为未定义。函数返回void
c.pop_front()   // 删除c中首元素。若c为空，则函数行 未定义。函数返回 void
c.erase(p)      // 删除迭代器 p 所指定的元素，返回一个指向被删元素之后元素的迭代器，若p指向尾元素，则返回尾后（off-the-end）迭代器。若p 是尾后迭代器，则函数行为未定义。

c.erase(b,e)    // 删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器。

c.clear()       // 删除c中的所有元素。返回 void


注意: 刪除 deque 中除首尾位置之外的任何元素都会使所有选代器、引用和指针失效。指向 vector 或 string 中刪除点之后位置的选代器、引用和指针都会失效。
删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它（们）是存在的。

*/

/*
删除元素

pop_front 和 pop_back 成员函数

pop_front 和pop_back成员函数分别删除首元素和尾元素。
与vector和 string 不支持 push front一样，这些类型也不支持 pop_front。
类似的，forward_list 不支持 pop_back。与元素访问成员函数类似，不能对一个空容器执行弹出操作。

从容器内部删除一个元素

成员函数 erase 从容器中指定位置删除元素。我们可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。
两种形式的 erase 都返回指向删除的（最后一个）元素之后位置的迭代器。

删除多个元素

接受一对迭代器的 erase 版本允许我们删除一个范围内的元素：
// 删除两个迭代器表示的范围内的元素
// 返回指向最后一个被删元素之后位置的迭代器
elem1 = slist.erase(elem1, elem2); // 调用后, elem1 == elem2
迭代器 elem1 指向我们要删除的第一个元素，elem2 指向我们要删除的最后一个元素之后的位置。

为了删除一个容器中的所有元素，我们既可以调用clear，也可以用 begin 和 end 获得的迭代器作为参数调用 erase：
slist.clear(); // 删除容器内所有元素
slist.erase(slist.begin(), slist.end()); // 等价调用

*/

/*
特殊的 forward_list 操作

在普通链表中，删除一个元素意味着改变目标元素前一个元素的指向。但是, forward_list是单向链表，没有简单的方法来获取目标元素的前一元素。
所以，在 forward_list 中，添加或删除元素的操作是通过改变给定元素之后的元素来完成的。

forward_list 定义了 insert_after, emplace_after, erase_after的操作。
为了支持这些操作，forward_list也定义了before_begin, 它返回一个 首前迭代器 。这个迭代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素（亦即在链表首元素之前添加删除 元素）。

在forward_list 中插入或删除元素的操作:

lst.before_begin()      // 返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。
lst.cbefore_begin()     // cbefore_begin() 返回一个 const_iterator

lst.insert_after(p,t)   // 在迭代器 p 之后插入元素 t
lst.insert_after(p,n,t) // n 是数量
lst.insert_after(p,b,e) // b 和 e 是表示范围的一对迭代器(b e 不能指向llst内)
lst.insert_after(p,il)  // il 是一个花括号列表。返回一个指向最后一个插入元素的迭代器。如果范围为空，则返回 p。若 p 为尾后迭代器，则函数行为未定义。

emplace_after(p,args)   // 使用 args 在p指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若p 为尾后迭代器，则函数行为未定义。

lst.erase_after(p,args) // 删除p 指向的位置之后的元素
lst.erase_after(b,e)    // 删除从b之后直到（但不包含）e之间的元素。返回一个指向被删元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器。如果 p 指向 lst 的尾元素或者是一个尾后迭代器，则函数行为未定义。

*/


/*
改变容器大小

可以用resize 来增大或缩小容器，与往常一样，array 不支 持 resize。如
果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小 小于新大小，会将新元素添加到容器后部。

list<int> ilist(10, 42);    // 10个int: 每个的值都是 42
ilist.resize(15);           // 将5个值为0的元素添加到ilist 的末尾
ilist.resize(25, -1);       // 将10个值为-1的元素添加到ilist的末尾
ilist.resize(5);            // 从ilist 末尾删除20个元素

c.resize(n)     // 调整c的大小为n 个元素。若n<c.size（），则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化
c.resize(n,t)   // 调整c的大小为n个元素。任何新添加的元素都初始化为值七

注意: 如果 resize 缩小容器，则指向被删除元素的选代器、引用和指针都会失效；
对 vector、string 或 deque 进行 resize 可能导致选代器、指针和引用失效。


容器操作可能使迭代器失效

如果容器是 vector 或 string，且存储空间被重新分配，则指向容器的迭代器、 指针和引用都会失效。
如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。 

对于 deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。
如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。 
对于 list 和 forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。

我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效。当我们删除一个元素后： 
对于 list 和 forward_list，指向容器其他位置的迭代器（包括尾后迭代器和 首前迭代器）、引用和指针仍有效。

对于 deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他 元素的迭代器、引用或指针也会失效。
如果是删除deque 的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。 

对于 vector 和 string，指向被删元素之前元素的迭代器、引用和指针仍有效。 注意：当我们删除元素时，尾后迭代器总是会失效。

不要保存end返回的迭代器

当我们添加/删除 vector 或 string 的元素后，或在deque 中首元素之外任何位置添加/删除元素后，原来 end 返回的迭代器总是会失效。
因此，添加或删除元素的循环程序必须反复调用 end，而不能在循环之前保存end 返回的迭代器，一直当作容器末尾使用。

*/
