### 7.5 构造函数再探

- 构造函数的初始值

如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。

```cpp

class ConstRef
{
public:
    ConstRef(int ii);
private:
    int i;
    const int ci;
    int &ri;
}

// 显式地初始化引用和 const 成员
ConstRef::ConstRef(int ii) : i(ii), ci(ii), ri(i) { }

```


- 成员初始化的顺序

成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。

```cpp

class X 
{
    int i;
    int j;
public:
    // X(int val) : j(val), i(j) { }  未定义的：主在j之前被初始化

    X(int val) : i(val), j(i) { }
}

```


- 默认实参和构造函数

#### 显式构造函数的优先级

在类中，一旦你定义了任何构造函数（包括带默认参数的构造函数），编译器将不会自动生成默认的构造函数。

#### 带默认参数的构造函数等效于无参构造函数

``` cpp

/**
一旦在类中定义了任意构造函数，编译器不会自动生成默认构造函数(default)，除非你显式地声明 = default。

由于 Sales_data(std::string s = "") 提供了默认参数 s = ""，因此可以在不提供实参时直接调用这个构造函数，等效于调用无参构造函数。
因此，这个构造函数已经满足了无参构造的需求。
*/
Sales_data::Sales_data(string s="") : bookNo(s) { } 

```

- 委托构造函数

注: 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。

- 默认构造函数的作用

- 隐式的类类型转换

- `explicit` 关键字抑制构造函数定义的隐式转换

- 聚合类

- 字面值常量类

- constexpr 构造函数

