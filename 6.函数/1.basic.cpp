#include <iostream>
#include <string>
#include <vector>
#include "Chapter6.h"
using namespace std;

/**
 * 函数是一个命名了的代码块，我们通过调用函数执行相应的代码。
 * 函数可以有0个或 多个参数，而且（通常）会产生一个结果。
 * 可以重载函数，也就是说，同一个名字可以对 应几个不同的函数。
 * 
 * 一个典型的函数定义包括以下部分:
 * 返回类型, 函数名, 由0个或多个形参组成的列表以及函数体。
 * 
 * 我们通过 调用运算符 来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，
 * 该表达式是函数或指向函数的指针; 圆括号之内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。
 * 
 */

/**
 * 调用函数
 * 
 * 函数的调用主要完成两项工作, 一是用实参初始化函数对应的形参, 二是将控制权转移给被调用函数。
 * 此时，主调函数 的执行被暂时中断，被调函数 开始执行。
 * 
 * 当遇到一条return语句时函数结束执行过程。和函数调用一样，return语句也完成两项工作：
 * 一是返回return语句中的值(如果有的话)，二是将控制权从被调函数转移回主调函数。
 * 
 */

/**
 * 形参和实参
 * 
 * 实参是形参的初始值。
 * 第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。
 * 尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序，编译器能以任意可行的顺序对实参求值。
 * 实参的类型必须与对应的形参类型匹配。
 * 
 */


/** 求阶乘函数 */
void fact()
{
    int ret = 1;
    int val = 0;
    cout << "请输入需要计算阶乘的数: ";
    // 获取用户输入
    cin >> val;
    // 格式化输出结果
    cout << val;
    // 计算阶乘
    while (val > 1)
        ret *= val--;
    // 格式化输出结果
    cout  << "! is: " << ret << endl;
}

/** 一个同时用到形参，局部变量，局部静态变量的示例函数 */
int simple(int n)
{
    static int i = 0;
    i += n;

    return i;
}

/** 计数函数，当它第一次被调用时返回0，以后每次被调用返回值加1 */
int count()
{
    static int cnt = 0;
    cout << "该计数函数已被调用: " << cnt++ << " 次!" << endl;
    
    return cnt;
}


int main()
{
    /** 求阶乘函数示例 */
    fact();

    /**
     * 局部对象
     * 
     * 1. 局部变量
     * 块构成一个新的作用域，我们可以在其中定义变量。形参和函数体内部定义的变量统称局部变量。
     * 
     * 2. 自动对象
     * 对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。
     * 我们把只存在于块执行期间的对象称为自动对象（automatic object）。
     * 当块的执行结束后，块中创建的自动对象的值就变成未定义的了。
     * 形参是一种自动对象。函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁。
     * 
     * 3. 局部静态对象
     * 局部静态对象 （local static object）在程序的执行路径第一次经过对象定义语句时初始化，
     * 并且直到程序终止才被销毁，在此期间即使 对象所在的函数结束执行也不会对它有影响。
     * 
     */

    /** 计数函数测试 */
    count();    // 0
    count();    // 1
    count();    // 2

    /**
     * 函数声明(函数原型)
     * 
     * 函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。
     * 因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。
     * 尽管如此，写上形参的名字还是有用处的，它可以帮助使用者更好 地理解函数的功能。
     * 
     */

    /**
     * 分离式编程
     * 
     * 编译器对程序的编译主要包含以下四步:
     * 1. 预处理
     *  这个阶段，主要做了三件事: 展开头文件、宏替换、去掉注释语句, 最终得到的还是源文件, 文本格式(.i)
     * 2. 编译
     *  gcc调用编译器对文件进行编译, 得到一个汇编文件(.s)
     * 3. 汇编
     *  gcc调用汇编器对文件进行汇编, 得到一个二进制文件(.o)
     * 4. 链接
     *  gcc调用链接器，对程序需要调用的库进行链接，最终得到一个可执行的二进制文件
     * 
     * 文件名后缀        说明                       gcc参数
     * .c           源文件                          无
     * .i           预处理后的c文件                  -E(gcc -E app.c -o app.i)
     * .s           编译后得到的汇编语言的源文件       -S(gcc -S app.i -o app.s)
     * .o           汇编后得到的二进制文件            -c(gcc -c app.s -o app.o)
     *                                            gcc链接命令 gcc app.o -o app
     */

    return 0;
}