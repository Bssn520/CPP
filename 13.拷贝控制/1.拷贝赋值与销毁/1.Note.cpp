/*

当定义一个类时，我们显示或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时如何进行。

一个类通过定义五种特殊的成员函数来控制上述操作：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数：
拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么；
拷贝和移动赋值运算符定义了将一个对象赋予另一个同类型的对象时做什么；
析构函数定义了当前类型销毁时做什么；

上述的这些操作称为 拷贝操作控制。

拷贝、赋值与销毁

1. 拷贝构造函数

如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数：
class Foo
{
public:
    Foo ();             // 默认构造函数
    Foo(const Foo&);    // 拷贝构造函数
}

合成拷贝构造函数
如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个，即合成拷贝构造函数。
合成拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中将每个非static成员拷贝到正在创建的对象中。


2. 拷贝赋值运算符

class Foo
{
public:
    Foo& operator=(const Foo&); // 赋值运算符
    // ...
}

合成拷贝赋值运算符

Sales_data&
Sales_data::operator=(const Sales_data &rhs)
{
    bookNo = rhs.bookNo;    // 调用 string::operator=
    units_sold = rhs.units_sold;    // 使用内置的 int 赋值
    revenue = rhs.revenue;      // 使用内置的 double 赋值
    return *this;   // 返回一个此对象的引用
}


3. 析构函数

析构函数释放对象所使用的资源，并销毁对象的非 static 数据成员。

析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数：
class Foo
{
public:
    ~Foo(); // 析构函数
    // ...
}
由于析构函数不接受参数，因此无法被重载。一个给定的类，只有唯一一个析构函数。

析构函数完成什么工作

在一个析构函数中，首先执行函数体，然后销毁成员。成员按照初始化顺序的逆序销毁。

什么时候会调用析构函数

无论何时一个对象被销毁，就会自动调用其析构函数：
- 变量在离开其作用域时被销毁。
- 当一个对象被销毁时，其成员被销毁。
- 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。
- 对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁。
- 对于临时对象，当创建它的完整表达式结束时被销毁。

合成析构函数

当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。

下面的代码片段等价于 Sales_data 的合成析构函数：
class Sales_data
{
public:
    ~Sales_data() { }
}

ex 09:
析构函数是什么？合成析构函数完成什么工作？什么时候会生成合成析构函数？

答：
析构函数是类的一个成员函数，名字由波浪号和类名组成(如~Sales_data())，它没有返回值，也不接受参数，用于释放对象所使用的资源，并销毁对象的非static数据成员；
当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。

4. 三/五法则

需要析构函数的类也需要拷贝和赋值操作

需要拷贝操作的类也需要赋值操作，反之亦然


5. 使用 =default

我们可以通过将拷贝控制成员定义=default来显式地要求编译器生成合成的版本：
Sales_data
{
public:
    Sales_data() = default;
    Sales_data(const Sales_data&) = default;
    Sales_data operator=(const Sales_data&);
    ~Sales_data() = default;
}
Sales_data& Sales_data::operator=(const Sales_data&)=default;

当我们在类内用=default 修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样）。
如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，就像对拷贝赋值运算符所做的那样。


6. 阻止拷贝

定义删除的函数

新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为 删除的函数 来阻止拷贝。
删除的函数：虽然声明了它们，但不能以任何方式使用它们。在函数参数列表后加上=delete来指出一个函数为删除的函数：
struct NoCopy
{
    NoCopy = default;
    NoCopy(const NoCopy&) = delete;
    NoCopy &operator=(const NoCopy&) = delete;
    ~NoCopy() = default;
}
与 =default 不同，可以对任何函数指定=delete；

析构函数不能是删除的成员

不能删除析构函数，因为如果析构函数被删除，就无法销毁此类型的对象了

合成的拷贝控制成员可能是删除的

合成拷贝控制成员的删除条件

析构函数：
成员析构函数删除或不可访问 → 合成析构函数删除
成员析构函数删除或不可访问 → 合成拷贝构造函数删除
拷贝构造函数：
成员拷贝构造函数删除或不可访问 → 合成拷贝构造函数删除
拷贝赋值运算符：
成员拷贝赋值运算符删除或不可访问 → 合成拷贝赋值运算符删除
类有const或引用成员 → 合成拷贝赋值运算符删除
默认构造函数：
成员析构函数删除或不可访问 → 合成默认构造函数删除
类有引用成员且无类内初始化器 → 合成默认构造函数删除
类有const成员且无类内初始化器且类型未显式定义默认构造函数 → 合成默认构造函数删除

析构函数：删或不可访问，合成析构和拷贝构造都删除。
拷贝构造：删或不可访问，合成拷贝构造删除。
拷贝赋值：删或不可访问，或const/引用成员，合成拷贝赋值删除。
默认构造：删或不可访问，或引用无初始化器，或const无初始化器且无显式默认构造，合成默认构造删除。

private 拷贝控制

新标准之前，类通过将其拷贝构造函数和拷贝赋值运算符声明为 private 来阻止拷贝：
class PrivateCopy
{
public:
    PrivateCopy() = default;
    ~PrivateCopy();
private:
    PrivateCopy(const PrivateCopy&);
    PrivateCopy &operator(const PrivateCopy&);
}

由于析构函数是public的，用户可以定义PrivateCopy类型对象。但是由于拷贝构造函数和拷贝赋值运算符是private的，用户代码不能拷贝这个类型的对象。
但是友元和成员函数仍旧可以拷贝对象。为了阻止友元和成员函数进行拷贝，我们只声明不定义这些函数；这样会导致编译链接时错误。

*/
